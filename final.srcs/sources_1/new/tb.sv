`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 03/13/2024 06:58:36 PM
// Design Name: 
// Module Name: tb
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module tb;

// Testbench uses reg for inputs to the modules and wires for the connections between modules
logic        clk_tb;
logic        rst_n_tb;

logic [7:0]  gpio_offset_tb;
logic [7:0]  gpio_mult_tb;

logic [7:0]  GPIO_CMDREG_tb;
enum logic [1:0] {READ = 0, COMPLEMENT = 1, ADD = 2, MULT = 3} opcode_tb;
logic [2:0] addr_tb;
logic execute_tb;
assign GPIO_CMDREG_tb = {opcode_tb, addr_tb, 2'b00, execute_tb};

logic [31:0] GPIO_RD_tb;
//logic        clk_sm_tb;
logic [31:0] BRAM_PORT_RD_addr_tb;
logic        BRAM_PORT_RD_clk_tb;
logic [31:0] BRAM_PORT_RD_data_tb;
logic        BRAM_PORT_RD_en_tb;
logic        BRAM_PORT_RD_rst_tb;

// Instantiate the cpm_wrapper module
//cpm_wrapper cpm (
//    .BRAM_PORT_RD_addr(BRAM_PORT_RD_addr_tb),
//    .BRAM_PORT_RD_clk(BRAM_PORT_RD_clk_tb),
//    .BRAM_PORT_RD_dout(BRAM_PORT_RD_data_tb),
//    .BRAM_PORT_RD_en(BRAM_PORT_RD_en_tb),
//    .BRAM_PORT_RD_rst(BRAM_PORT_RD_rst_tb),
//    .GPIO_CMDREG_tri_i(GPIO_CMDREG_tb),
//    .GPIO_RD_tri_i(GPIO_RD_tb),
//    .clk_sm(clk_sm_tb),
//    .gpio_mult_tri_o(gpio_mult_tb),
//    .gpio_offset_tri_i(gpio_offset_tb),
//    .reset_n(rst_n_tb),
//    .sys_clock(clk_tb)
//    );

// Instantiate the fsm module
fsm fsm (
    .reset_n(rst_n_tb),
    .clk(clk_tb),                // use clock generated by clocking wizard
    .GPIO_CMDREG(GPIO_CMDREG_tb),
    .GPIO_RD(GPIO_RD_tb),
    .gpio_offset(gpio_offset_tb),
    .gpio_mult(gpio_mult_tb),
    .BRAM_PORT_RD_addr(BRAM_PORT_RD_addr_tb),
    .BRAM_PORT_RD_clk(BRAM_PORT_RD_clk_tb),
    .BRAM_PORT_RD_data(BRAM_PORT_RD_data_tb),
    .BRAM_PORT_RD_en(BRAM_PORT_RD_en_tb),
    .BRAM_PORT_RD_rst(BRAM_PORT_RD_rst_tb)
    );

// Instantiate dummy ROM
rom rom (
    .rst(BRAM_PORT_RD_rst_tb),
    .clk(clk_tb),
    .addr(BRAM_PORT_RD_addr_tb),
    .data(BRAM_PORT_RD_data_tb),
    .en(BRAM_PORT_RD_en_tb)
    );


// Clock generation
initial begin
    clk_tb = 0;
    forever #5 clk_tb = ~clk_tb; // Generate a clock with a period of 10 ns
end

// Test stimulus
initial begin
    // Reset
    rst_n_tb = 0;
    #200;
    rst_n_tb = 1;

    // Test case 1: read
    #30
    opcode_tb = READ;
    addr_tb = 0;
    execute_tb = 1;
    #40
    execute_tb = 0;
    
    // Test case 2: complement
    #30
    opcode_tb = COMPLEMENT;
    addr_tb = 1;
    execute_tb = 1;
    #40
    execute_tb = 0;
    
    // Test case 3: add
    #30
    opcode_tb = ADD;
    addr_tb = 2;
    gpio_offset_tb = 9;
    execute_tb = 1;
    #40
    execute_tb = 0;
    
    // Test case 4: multiply
    #30
    opcode_tb = MULT;
    addr_tb = 3;
    gpio_mult_tb = 104;
    execute_tb = 1;
    #50
    execute_tb = 0;

    #6000; // Run the simulation for a set time
    $finish; // End the simulation
end

endmodule
